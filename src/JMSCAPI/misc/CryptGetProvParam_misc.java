package JMSCAPI.misc;

import com.sun.jna.Structure;
import com.sun.jna.platform.win32.WinDef.DWORD;




public interface CryptGetProvParam_misc {
	
	/**
	 * The error codes prefaced by NTE are generated by the particular CSP being used.
	 * Some possible error codes returned by <b>GetLastError()</b>:
	 *																									</p><table><tr> 
	 * <td>ERROR_INVALID_HANDLE</td>	<td>One of the parameters specifies a handle that is
	 * 										not valid.													</td></tr><tr>
	 * 
	 * <td>ERROR_INVALID_PARAMETER = 87</td><td>One of the parameters contains a value that is not 
	 * 										valid. This is most often a pointer that is not valid.		</td></tr><tr>
	 * 
	 * <td>ERROR_MORE_DATA</td>			<td>If the buffer specified by the pbData parameter is not
	 * 										large enough to hold the returned data, the function
	 * 										sets the <code>ERROR_MORE_DATA</code> code and stores
	 * 										the required buffer size, in bytes, in the variable
	 * 										pointed to by <b>pdwDataLen</b>.							</td></tr><tr>
	 * 
	 * <td>ERROR_NO_MORE_ITEMS = 259</td><td>The end of the enumeration list has been reached. No
	 * 										valid data has been placed in the <b>pbData</b> buffer.
	 * 										This error code is returned only when <b>dwParam</b>
	 * 										equals <code>PP_ENUMALGS</code> or 
	 * 										<code>PP_ENUMCONTAINERS</code>.								</td></tr><tr>
	 * 
	 * <td>NTE_BAD_FLAGS</td>			<td>The <b>dwFlags</b> parameter specifies a flag that is
	 * 										not valid.													</td></tr><tr>
	 * 
	 * <td>NTE_BAD_TYPE = 8009000A</td>	<td>The <b>dwParam</b> parameter specifies an unknown value
	 * 										number.														</td></tr><tr>
	 * 
	 * <td>NTE_BAD_UID</td>				<td>The CSP context specified by <b>hProv</b> is not valid.		</td></tr>
	 *																									</table>
	 */
	public static String error_codes = "error codes";
	
/* dwParam possible values: */////////////////////////////////////////////////////////////
	/**
	 * Possible dwParam values: 																		<ul>
	 * <li>{@linkplain #PP_ADMIN_PIN}</li>
	 * <li>{@linkplain #PP_CERTCHAIN}</li>
	 * <li>{@linkplain #PP_CONTAINER}</li>
	 * <li>{@linkplain #PP_ENUMALGS}</li>
	 * <li>{@linkplain #PP_ENUMALGS_EX}</li>
	 * <li>{@linkplain #PP_ENUMCONTAINERS}</li>
	 * <li>{@linkplain #PP_ENUMEX_SIGNING_PROT}</li>
	 * <li>{@linkplain #PP_IMPTYPE}</li>
	 * <li>{@linkplain #PP_KEYEXCHANGE_PIN}</li>
	 * <li>{@linkplain #PP_KEYSET_SEC_DESCR}</li>
	 * <li>{@linkplain #PP_KEYSET_TYPE}</li>
	 * <li>{@linkplain #PP_KEYSPEC}</li>
	 * <li>{@linkplain #PP_KEYSTORAGE}</li>
	 * <li>{@linkplain #PP_KEYX_KEYSIZE_INC}</li>
	 * <li>{@linkplain #PP_NAME}</li>
	 * <li>{@linkplain #PP_PROVTYPE}</li>
	 * <li>{@linkplain #PP_ROOT_CERTSTORE}</li>
	 * <li>{@linkplain #PP_SESSION_KEYSIZE}</li>
	 * <li>{@linkplain #PP_SGC_INFO}</li>
	 * <li>{@linkplain #PP_SIG_KEYSIZE_INC}</li>
	 * <li>{@linkplain #PP_SIGNATURE_PIN}</li>
	 * <li>{@linkplain #PP_SMARTCARD_GUID}</li>
	 * <li>{@linkplain #PP_SMARTCARD_READER}</li>
	 * <li>{@linkplain #PP_SYM_KEYSIZE}</li>
	 * <li>{@linkplain #PP_UNIQUE_CONTAINER}</li>
	 * <li>{@linkplain #PP_USE_HARDWARE_RNG}</li>
	 * <li>{@linkplain #PP_USER_CERTSTORE}</li>
	 * <li>{@linkplain #PP_VERSION}</li></ul>
	 */
	public static String dwParam = "dwParam";
	
	/**
	 * Returns the administrator personal identification number (PIN) in the <b>pbData</b>
	 * parameter as a LPSTR.
	 */
	public static final int PP_ADMIN_PIN = 31;
	
	/**
	 * Returns the certificate chain associated with the <b>hProv</b> handle. The returned
	 * certificate chain is <b>X509_ASN_ENCODING</b> encoded.
	 */
	public static final int PP_CERTCHAIN = 9;
	
	/**
	 * The name of the current key container as a <b>null</b>-terminated <b>CHAR</b> string.
	 * This string is exactly the same as the one passed in the <b>pszContainer</b> parameter of the	 {@link JMSCAPI.Advapi32#CryptAcquireContextW
	 * CryptAcquireContext} function to specify the key container to use. The <b>pszContainer</b>
	 * parameter can be read to determine the name of the default key container.
	 */
	public static final int PP_CONTAINER = 6;
	
	/**
	 * A <b>PROV_ENUMALGS</b> structure that contains information about one algorithm
	 * supported by the CSP being queried.																
	 * 																									<p>
	 * The first time this value is read, the <b>dwFlags</b> parameter must contain the
	 * <code>CRYPT_FIRST</code> flag. Doing so causes this function to retrieve the first element
	 * in the enumeration. The subsequent elements can then be retrieved by setting the 
	 * <code>CRYPT_NEXT</code> flag in the <b>dwFlags</b> parameter. When this function fails with
	 * the <code>ERROR_NO_MORE_ITEMS</code> error code, the end of the enumeration has been reached.
	 * 																									<p>
	 * This function is not thread safe, and all of the available algorithms might not be enumerated
	 * if this function is used in a multithreaded context.
	 */
	public static final int PP_ENUMALGS = 1;
	
	/**
	 * A <b>PROV_ENUMALGS_EX</b> structure that contains information about one algorithm
	 * supported by the CSP being queried. The structure returned contains more information about
	 * the algorithm than the structure returned for <b>PP_ENUMALGS</b>.
	 * 																									<p>
	 * The first time this value is read, the <b>dwFlags</b> parameter must contain the
	 * <code>CRYPT_FIRST</code> flag. Doing so causes this function to retrieve the first element
	 * in the enumeration. The subsequent elements can then be retrieved by setting the 
	 * <code>CRYPT_NEXT</code> flag in the <b>dwFlags</b> parameter. When this function fails with
	 * the <code>ERROR_NO_MORE_ITEMS</code> error code, the end of the enumeration has been reached.
	 * 																									<p>
	 * This function is not thread safe, and all of the available algorithms might not be enumerated
	 * if this function is used in a multithreaded context.
	 */
	public static final int PP_ENUMALGS_EX = 22;
	
	/**
	 * The name of one of the key containers maintained by the CSP in the form of a
	 * <b>null</b>-terminated <b>CHAR</b> string.
	 * 																									<p>
	 * The first time this value is read, the <b>dwFlags</b> parameter must contain the
	 * <code>CRYPT_FIRST</code> flag. Doing so causes this function to retrieve the first element
	 * in the enumeration. The subsequent elements can then be retrieved by setting the 
	 * <code>CRYPT_NEXT</code> flag in the <b>dwFlags</b> parameter. When this function fails with
	 * the <code>ERROR_NO_MORE_ITEMS</code> error code, the end of the enumeration has been reached.
	 * 																									<p>
	 * To enumerate key containers associated with a computer, first call 								{@link JMSCAPI.Advapi32#CryptAcquireContextW
	 * CryptAcquireContext} using the <code>CRYPT_MACHINE_KEYSET</code> flag, and then use the
	 * handle returned from <b>CryptAcquireContext</b> as the <b>hProv</b> parameter in the call
	 * to <b>CryptGetProvParam</b>.
	 * 																									<p>
	 * This function is not thread safe, and all of the available algorithms might not be enumerated
	 * if this function is used in a multithreaded context.
	 */
	public static final int PP_ENUMCONTAINERS = 2;
	
	/**
	 * Indicates that the current CSP supports the <b>dwProtocols</b> member of the
	 * <b>PROV_ENUMALGS_EX</b> structure. If this function succeeds, the CSP supports the 
	 * dwProtocols member of the PROV_ENUMALGS_EX structure. If this function fails with an
	 * <code>NTE_BAD_TYPE</code> error code, the CSP does not support the dwProtocols member.
	 */
	public static final int PP_ENUMEX_SIGNING_PROT = 40;
	
	/**
	 * A DWORD value that indicates how the CSP is implemented.											<br/>
	 * The following values are returned in pbData if <b>dwParam</b> is <code>PP_IMPTYPE</code>.
	 * 																									<p><table><tr>
	 * <td>CRYPT_IMPL_HARDWARE = 1	</td>	<td>Implementation is in hardware.							</td></tr><tr>
	 * <td>CRYPT_IMPL_SOFTWARE = 2	</td>	<td>Implementation is in software.							</td></tr><tr>
	 * <td>CRYPT_IMPL_MIXED = 3		</td>	<td>Implementation involves both hardware and software.		</td></tr><tr>
	 * <td>CRYPT_IMPL_UNKNOWN = 4	</td>	<td>Implementation type is unknown.							</td></tr><tr>
	 * <td>CRYPT_IMPL_REMOVABLE = 8	</td>	<td>Implementation is in removable media.					</td></tr></table>
	 */
	public static final int PP_IMPTYPE = 3;
	
	/**
	 * Specifies that the key exchange PIN is contained in pbData. The PIN is represented
	 * as a <b>null</b>-terminated <b>ASCII</b> string.
	 */
	public static final int PP_KEYEXCHANGE_PIN = 32;
	
	/**
	 * Retrieves the security descriptor for the key storage container. The <b>pbData</b>
	 * parameter is the address of a <code>SECURITY_DESCRIPTOR</code> structure that receives the
	 * security descriptor for the key storage container. The security descriptor is returned in
	 * self-relative format.
	 */
	public static final int PP_KEYSET_SEC_DESCR = 8;
	
	/**
	 * Determines whether the <b>hProv</b> parameter is a computer key set. The <b>pbData</b>
	 * parameter must be a DWORD; the DWORD will be set to the <code>CRYPT_MACHINE_KEYSET</code>
	 * flag if that flag was passed to the  															{@link JMSCAPI.Advapi32#CryptAcquireContextW
	 * CryptAcquireContext} function.
	 */
	public static final int PP_KEYSET_TYPE = 27;
	
	/**
	 * Returns information about the key specifier values that the CSP supports. Key specifier
	 * values are joined in a logical OR and returned in the <b>pbData</b> parameter of the call
	 * as a DWORD. For example, the Microsoft Base Cryptographic Provider version 1.0 returns
	 * a DWORD value of <code>AT_SIGNATURE | AT_KEYEXCHANGE</code>.
	 */
	public static final int PP_KEYSPEC = 39;
	
	/**
	 * Returns a DWORD value of <code>CRYPT_SEC_DESCR</code>.	
	 */
	public static final int PP_KEYSTORAGE = 17;
	
	/**
	 * The number of bits for the increment length of <code>AT_KEYEXCHANGE</code>. This
	 * information is used with information returned in the <code>PP_ENUMALGS_EX</code> value.
	 * With the information returned when using <code>PP_ENUMALGS_EX</code> and 
	 * <code>PP_KEYX_KEYSIZE_INC</code>, the valid key lengths for <code>AT_KEYEXCHANGE</code>
	 * can be determined. These key lengths can then be used with <b>CryptGenKey</b>. 
	 * 																									<p>
	 * For example if a CSP enumerates <code>CALG_RSA_KEYX (AT_KEYEXCHANGE)</code> with a minimum
	 * key length of 512 bits and a maximum of 1024 bits, and returns the increment length as
	 * 64 bits, then valid key lengths are 512, 576, 640,… 1024.
	 */
	public static final int PP_KEYX_KEYSIZE_INC = 35;
	
	/**
	 * The name of the CSP in the form of a <b>null</b>-terminated <b>CHAR</b> string. This string
	 * is identical to the one passed in the <b>pszProvider</b> parameter of the  						{@link JMSCAPI.Advapi32#CryptAcquireContextW
	 * CryptAcquireContext} function to specify that the current CSP be used.
	 */
	public static final int PP_NAME = 4;
	
	/**
	 * A DWORD value that indicates the provider type of the CSP.
	 */
	public static final int PP_PROVTYPE = 16;
	
	/**
	 * Obtains the root certificate store for the smart card. This certificate store contains all
	 * of the root certificates that are stored on the smart card.
	 * 																									<p>
	 * The <b>pbData</b> parameter is the address of an <code>HCERTSTORE</code> variable that
	 * receives the handle of the certificate store. When this handle is no longer needed, the
	 * caller must close it by using the <b>CertCloseStore</b> function.
	 */
	public static final int PP_ROOT_CERTSTORE = 46;
	
	/**
	 * The size, in bits, of the session key.
	 */
	public static final int PP_SESSION_KEYSIZE = 20;
	
	/**
	 * Used with server gated cryptography.
	 */
	public static final int PP_SGC_INFO = 37;
	
	/**
	 * The number of bits for the increment length of <code>AT_SIGNATURE</code>. This information
	 * is used with information returned in the <code>PP_ENUMALGS_EX</code> value. With the
	 * information returned when using <code>PP_ENUMALGS_EX</code> and <code>PP_SIG_KEYSIZE_INC</code>,
	 * the valid key lengths for <code>AT_SIGNATURE</code> can be determined. These key lengths
	 * can then be used with <b>CryptGenKey</b>.
	 * 																									<p>
	 * For example, if a CSP enumerates <code>CALG_RSA_SIGN (AT_SIGNATURE)</code> with a minimum
	 * key length of 512 bits and a maximum of 1024 bits, and returns the increment length as
	 * 64 bits, then valid key lengths are 512, 576, 640,… 1024.
	 */
	public static final int PP_SIG_KEYSIZE_INC = 34;
	
	/**
	 * Specifies that the key signature PIN is contained in <b>pbData</b>. The PIN is represented
	 * as a <b>null</b>-terminated <b>ASCII</b> string.
	 */
	public static final int PP_SIGNATURE_PIN = 33;
	
	/**
	 * Obtains the identifier of the smart card. The <b>pbData</b> parameter is the address of a
	 * GUID structure that receives the identifier of the smart card.
	 */
	public static final int PP_SMARTCARD_GUID = 45;
	
	/**
	 * Obtains the name of the smart card reader. The <b>pbData</b> parameter is the address of
	 * an ANSI character array that receives a <b>null</b>-terminated ANSI string that contains
	 * the name of the smart card reader. The size of this buffer, contained in the variable
	 * pointed to by the <b>pdwDataLen</b> parameter, must include the <b>NULL</b> terminator.
	 */
	public static final int PP_SMARTCARD_READER = 43;
	
	/**
	 * The size of the symmetric key.
	 */
	public static final int PP_SYM_KEYSIZE = 19;
	
	/**
	 * The unique container name of the current key container in the form of a
	 * <b>null</b>-terminated <b>CHAR</b> string. For many CSPs, this name is the same name
	 * returned when the <code>PP_CONTAINER</code> value is used. The 			  						{@link JMSCAPI.Advapi32#CryptAcquireContextW
	 * CryptAcquireContext} function must work with this container name.
	 */
	public static final int PP_UNIQUE_CONTAINER = 36;
	
	/**
	 * Indicates whether a hardware random number generator (RNG) is supported. When
	 * <code>PP_USE_HARDWARE_RNG</code> is specified, the function succeeds and returns TRUE 
	 * if a hardware RNG is supported. The function fails and returns FALSE if a hardware RNG
	 * is not supported. If a RNG is supported, <code>PP_USE_HARDWARE_RNG</code> can be set in
	 * <b>CryptSetProvParam</b> to indicate that the CSP must exclusively use the hardware RNG
	 * for this provider context. When <code>PP_USE_HARDWARE_RNG</code> is used, the <b>pbData</b>
	 * parameter must be <code>NULL</code> and <b>dwFlags</b> must be zero.
	 * 																									<p>
	 * None of the Microsoft CSPs currently support using a hardware RNG.
	 */
	public static final int PP_USE_HARDWARE_RNG = 38;
	
	/**
	 * Obtains the user certificate store for the smart card. This certificate store contains all
	 * of the user certificates that are stored on the smart card. The certificates in this store
	 * are encoded by using <code>PKCS_7_ASN_ENCODING</code> or <code>X509_ASN_ENCODING</code>
	 * encoding and should contain the <b>CERT_KEY_PROV_INFO_PROP_ID</b> property.
	 * 																									<p>
	 * The <b>pbData</b> parameter is the address of an <code>HCERTSTORE</code> variable that
	 * receives the handle of an in-memory certificate store. When this handle is no longer needed,
	 * the caller must close it by using the <b>CertCloseStore</b> function.
	 */
	public static final int PP_USER_CERTSTORE = 42;
	
	/**
	 * The version number of the CSP. The least significant byte contains the minor version number
	 * and the next most significant byte the major version number. Version 2.0 is represented
	 * as 0x00000200. 
	 */
	public static final int PP_VERSION = 5;
	
////////////////////////////////////////////////////////////////////////////////////////////////////
/* PROV_ENUMALGS & PROV_ENUMALGS_EX structures *////////////////////////////////////////////////////
	
	/**
	 * The PROV_ENUMALGS structure is used with the CryptGetProvParam function when the PP_ENUMALGS
	 * parameter is retrieved to contain information about an algorithm supported by a cryptographic
	 * service provider (CSP).
	 * 
	 * @param aiAlgid	One of the ALG_ID values that identifies the algorithm.
	 * @param dwBitLen	The default key length, in bits, of the algorithm.
	 * @param dwNameLen	The length, in CHARs, of the szName string. This length includes the 
	 * 					terminating null character.
	 * @param szName	A null-terminated ANSI string that contains the name of the algorithm.
	 */
	public static class PROV_ENUMALGS extends Structure {
		public int aiAlgid;						
		public DWORD dwBitLen;
		public DWORD dwNameLen;
		public byte[] szName = new byte[20];		

	}
	/**
	 * The PROV_ENUMALGS_EX structure is used with the CryptGetProvParam function when the
	 * <code>PP_ENUMALGS_EX</code> parameter is retrieved to contain information about an algorithm
	 * supported by a cryptographic service provider (CSP).
	 * 
	 * @param aiAlgid		One of the ALG_ID values that identifies the algorithm.
	 * @param dwDefaultLen	The default key length, in bits, of the algorithm.
	 * @param dwMinLen		The minimum key length, in bits, of the algorithm.
	 * @param dwMaxLen		The maximum key length, in bits, of the algorithm.
	 * @param dwProtocols	Zero or a combination of one or more of the 								<a href="http://msdn.microsoft.com/en-us/library/aa387429(v=vs.85).aspx">
	 * 						Protocol Flags</a> values that identifies the protocols supported
	 * 						by the algorithm.
	 * @param dwNameLen		The length, in CHARs, of the <b>szName</b> string. This length includes
	 * 						 the terminating null character.
	 * @param szName		A null-terminated ANSI string that contains the name of the algorithm.
	 * @param dwLongNameLen	The length, in CHARs, of the <b>szLongName</b> string. This length
	 * 						includes the terminating null character.
	 * @param szLongName	A null-terminated ANSI string that contains the long name of the
	 * 						algorithm.
	 *
	 */
	public static class PROV_ENUMALGS_EX extends Structure {
		public int aiAlgid;	
		public  DWORD  dwDefaultLen;
		public  DWORD  dwMinLen;
		public  DWORD  dwMaxLen;
		public  DWORD  dwProtocols;
		public  DWORD  dwNameLen;
		public 	byte[] szName = new byte[20];
		public  DWORD  dwLongNameLen;
		public 	byte[] szLongName = new byte[40];		
	}

	
	
/* dwFlags possible values *////////////////////////////////////////////////////////////////////////	

	
	/**
	 * Retrieve the first element in the enumeration. This has the same effect as resetting
	 * the enumerator.
	 */
	public static final int CRYPT_FIRST = 1;
	
	/**
	 * Retrieve the next element in the enumeration. When there are no more elements to retrieve,
	 * this function will fail and set the last error to <code>ERROR_NO_MORE_ITEMS</code>.
	 */
	public static final int CRYPT_NEXT = 2;
	
}
